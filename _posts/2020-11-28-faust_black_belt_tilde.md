---
layout: post
title: Three ways to implement non-trivial recursive circuits in the Faust language
date: 2020-11-28
description: this post shows examples to implement complex circuits in Faust
---
After a long silence, this post is about the implementation of not-so-simple recursive circuits in the Faust language. We will see a few relevant examples and the three main approaches that we can follow to implement a circuit: Faust's signal composition operators syntax (basic syntaxt, for short), the *with* environment with auxiliary function definition, and the *letrec* environment.

The Faust manual provides basic examples for the first and third approach, specifically using the "~" (tilde) recursive composition operator and the letrec environment for recursive definitions. As we will see later, Faust's basic syntax can be less concise and more complicated in some cases, whereas the remaining two approaches are easier. However, the basic syntax can be desirable if we want to generate diagrams that show the signal flow of a circuit more clearly. In this post, I will implement a few circuits with feedback using all of the three approaches.

Let's start with a simple one-pole lowpass filter, which is essentially a scaled-down input feeding into a leaky integrator. In the basic syntax, the tilde operator sends the signal(s) to its left through as well as back into a feedback path to fill the first available inputs in the function. The operands to the right of the tilde are applied in the feedback path. The tilde operator, unlike all other basic synthax operators, is left-assiociative and has highest priority. So, for example, if we write:

{% highlight faust linenos %}

import("stdfaust.lib");
process = + , _ : + : + ~ _;

{% endhighlight %}

we are summing the first two inputs, then we are sending the result together with a third input into another "+" operator, and then we are summing the result to the output itself. Of course, any feedback loop in a digital system requires at least a one-sample delay, which is the default delay in Faust's recursive composition. Suppose that we want to add another feedback loop in the previous function that is connected to the input of the first "+" operator. We also want to multiply that feedback signal by .5. Then we can write as follows:

{% highlight faust linenos %}

import("stdfaust.lib");
process = (+ , _ : + : + ~ _) ~ *(.5);

{% endhighlight %}

Back to the lowpass filter, we can see the diagram below, kindly taken from the site of the great Julius O. Smith. 

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <img class="img-fluid rounded z-depth-1" src="{{ site.baseurl }}/assets/img/lp1p_diagram.png">
    </div>
</div>

  
Following [Chamberlin 1985] for the design of the filter, we can write the function using the basic syntax as follows:

{% highlight faust linenos %}

import("stdfaust.lib");
lowpass(cf, x) = b0 * x : + ~ *(-a1)
    with {
        b0 = 1 + a1;
        a1 = exp(-w(cf)) * -1;
        w(f) = 2 * ma.PI * f / ma.SR;
    };
process = lowpass;

{% endhighlight %}

Below, we can see the diagram generated by the Faust code. Note that the empty little square on a wire indicates a one-sample delay, representing the z^-1 operator, in our case.

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <img class="img-fluid rounded z-depth-1" src="{{ site.baseurl }}/assets/img/lp1p_diagram_faust_a.png">
    </div>
</div>
<div class="caption">
    Block diagram generated through basic syntax.
</div>

Another way to implement the filter is by using an intermediate function and the *with* environment. I would also like to thank Oleg Nesterov who first introduced me to this technique. The intermediate function usually acts as container and defines elementary single or multiple feedback loops. The feedback loops that are sent back to the function can then be used anywhere in the inner code as they are identified by argument names, which are specified in the intermediate function ("loop") definition.

{% highlight faust linenos %}

import("stdfaust.lib");
lowpass(cf, x) = loop ~ _
    with {
        loop(feedback) = b0 * x - a1 * feedback;
        b0 = 1 + a1;
        a1 = exp(-w(cf)) * -1;
        w(f) = 2 * ma.PI * f / ma.SR;
    };
process = lowpass;

{% endhighlight %}

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <img class="img-fluid rounded z-depth-1" src="{{ site.baseurl }}/assets/img/lp1p_diagram_faust_b1.png">
    </div>
    <div class="col-sm mt-3 mt-md-0">
        <img class="img-fluid rounded z-depth-1" src="{{ site.baseurl }}/assets/img/lp1p_diagram_faust_b2.png">
    </div>
</div>
<div class="caption">
    Block diagram generated through intermediate function and the *with* environment.
</div>

The third way, perhaps the most elegant and concise, is through the *letrec* environment. Within this environment, we can define signals recursively, similarly to how recurrence equations are written.

{% highlight faust linenos %}

import("stdfaust.lib");
lowpass(cf, x) = y
    letrec {
        'y = b0 * x - a1 * y;
    }
        with {
            b0 = 1 + a1;
            a1 = exp(-w(cf)) * -1;
            w(f) = 2 * ma.PI * f / ma.SR;
        };
process = lowpass;

{% endhighlight %}

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <img class="img-fluid rounded z-depth-1" src="{{ site.baseurl }}/assets/img/lp1p_diagram_faust_c1.png">
    </div>
    <div class="col-sm mt-3 mt-md-0">
        <img class="img-fluid rounded z-depth-1" src="{{ site.baseurl }}/assets/img/lp1p_diagram_faust_c2.png">
    </div>
</div>
<div class="caption">
    Block diagram generated through the *letrec* environment.
</div>
