---
layout: post
title: Three ways to implement non-trivial recursive circuits in the Faust language
date: 2020-11-28
description: this post shows examples to implement complex circuits in Faust
---
After a long silence, this post is about the implementation of not-so-simple recursive circuits in the Faust language. We will see a few relevant examples and the three main approaches that we can follow to implement a circuit: core syntax, the *with* environment with auxiliary function definition, and the *letrec* environment.

The Faust manual provides basic examples for the first and third approach, specifically using the "~" (tilde) recursive composition operator (core syntax) and the letrec environment for recursive definitions. As we will see later, the core syntax is rather obsolete and complicated, whereas the remaining two approaches are easier. However, the core syntax can be desirable if we want to generate diagrams that show the signal flow of a circuit more clearly. In this post, I will implement a few circuits using all of the three approaches.

Let's start with a simple one-pole lowpass filter, which is essentially a scaled-down input feeding a leaky integrator. In the core syntax, the tilde operator sends the signal(s) to its left through as well as back into a feedback path to fill the first available inputs in the function. The operator(s) to the left of the tilde are applied in the feedback path. The tilde operator, unlike all other core synthax operators, is left-assiociative and has highest priority. So, for example, if we write:

{% highlight faust linenos %}

import("stdfaust.lib");
process = + , _ : + : + ~ _;

{% endhighlight %}

We are summing the first two inputs, then we are sending the result together with a third input into another "+" operator, and then we are summing the result to the output itself. Of course, any feedback loop in a digital system requires at least a one-sample delay, which is the default delay in Faust's recursive composition. Suppose that we want to add another feedback loop in the previous function that is connected to the input of the first "+" operator. We also want to multiply that feedback signal by half. Then we can write as follows:

{% highlight faust linenos %}

import("stdfaust.lib");
process = (+ , _ : + : + ~ _) ~ *(.5);

{% endhighlight %}

Back to the lowpass filter, we can see the diagram below, kindly taken from the site of the great Julius O. Smith. 

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <img class="img-fluid rounded z-depth-1" src="{{ site.baseurl }}/assets/img/lp1p_diagram.png">
    </div>
</div>

Following [Chamberlin 1985] for the design of the filter, we can write the function using the core syntax as follows:

{% highlight faust linenos %}

import("stdfaust.lib");
lowpass(cf, x) = b0 * x : + ~ *(-a1)
    with {
        b0 = 1 + a1;
        a1 = exp(-w(cf)) * -1;
        w(f) = 2 * ma.PI * f / ma.SR;
    };
process = lowpass;

{% endhighlight %}

Below, we can see the diagram generated by the Faust code. Note that the empty little square on a wire indicates a one-sample delay, representing the z^-1 operator.

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <img class="img-fluid rounded z-depth-1" src="{{ site.baseurl }}/assets/img/lp1p_diagram_faust.png">
    </div>
</div>
